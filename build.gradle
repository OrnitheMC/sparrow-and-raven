import java.nio.file.Files
import java.util.regex.Pattern

import groovy.json.JsonSlurper

import com.google.common.net.UrlEscapers
import io.github.gaming32.signaturechanger.cli.GenerateAction
import io.github.gaming32.signaturechanger.generator.SigsClassGenerator.EmptySignatureMode
import io.github.gaming32.signaturechanger.tree.MemberReference
import io.github.gaming32.signaturechanger.tree.SignatureInfo
import io.github.gaming32.signaturechanger.tree.SigsClass
import io.github.gaming32.signaturechanger.tree.SigsFile
import io.github.gaming32.signaturechanger.visitor.SigsFileWriter
import io.github.gaming32.signaturechanger.visitor.SigsReader
import net.ornithemc.exceptor.io.ExceptorIo
import net.ornithemc.exceptor.io.ExceptionsFile
import net.fabricmc.mappingio.MappingReader;
import net.fabricmc.mappingio.MappingWriter;
import net.fabricmc.mappingio.adapter.MappingSourceNsSwitch;
import net.fabricmc.mappingio.format.MappingFormat;
import net.fabricmc.mappingio.tree.MemoryMappingTree;
import net.ornithemc.keratin.Configurations
import net.ornithemc.keratin.api.TaskSelection
import net.ornithemc.keratin.api.task.mapping.Mapper
import net.ornithemc.keratin.api.task.mapping.FillMappingsTask
import net.ornithemc.keratin.api.task.mapping.PatchAnonymousClassMappingsTask
import net.ornithemc.keratin.api.task.processing.Exceptor
import net.ornithemc.keratin.api.task.processing.Nester
import net.ornithemc.keratin.api.task.processing.SignaturePatcher
import net.ornithemc.mappingutils.MappingUtils
import net.ornithemc.mappingutils.io.Format
import net.ornithemc.nester.nest.Nests
import net.ornithemc.nester.nest.NesterIo
import net.ornithemc.nester.nest.NestType
import org.apache.commons.io.FileUtils

plugins {
	id 'java'
	id 'maven-publish'
	id 'keratin' version '10.4'
	id 'de.undercouch.download' version '5.6.0'
}

def minecraft_version = '1.7.2'
def intermediary_gen = 2

def intermediaryTiny = file("build/${minecraft_version}-intermediary.tiny")
def featherJar = file("build/${minecraft_version}-feather.jar")
def featherTiny = file("build/${minecraft_version}-feather.tiny")
def mappingsTiny = file("build/${minecraft_version}-mappings.tiny")
def mergedMappingsTiny = file("build/${minecraft_version}-mappings-merged.tiny")

def setupDir = file('build/setup/')
def setupJar = new File(setupDir, "${minecraft_version}-setup.jar")
def setupExcs = new File(setupDir, "${minecraft_version}-setup.excs")
def setupSigs = new File(setupDir, "${minecraft_version}-setup.sigs")
def namedJar = new File(setupDir, "${minecraft_version}-named.jar")
def decompSrc = new File(setupDir, "${minecraft_version}-decompSrc")

def generatedDir = file('build/generated/')
def baseExcs = new File(generatedDir, "${minecraft_version}-base.excs")
def baseSigs = new File(generatedDir, "${minecraft_version}-base.sigs")
def generatedJar = new File(generatedDir, "${minecraft_version}-generated.jar")
def generatedExcs = new File(generatedDir, "${minecraft_version}-generated.excs")
def generatedSigs = new File(generatedDir, "${minecraft_version}-generated.sigs")

def excsDir = file('exceptions')
def excsOut = new File(excsDir, "${minecraft_version}.excs")
def sigsDir = file('signatures')
def sigsOut = new File(sigsDir, "${minecraft_version}.sigs")

setupDir.mkdirs()
generatedDir.mkdirs()
sigsDir.mkdirs()
excsDir.mkdirs()

base {
	archivesName = 'minecraft-patched'
}
version = minecraft_version

keratin {
	minecraftVersions minecraft_version
	intermediaryGen = intermediary_gen

	tasks TaskSelection.FEATHER_SETUP
}

configurations {
	def librariesConfigurationName = Configurations.minecraftLibraries(minecraft_version)
	def librariesConfiguration = configurations.getByName(librariesConfigurationName)

	decompileClasspath {
		extendsFrom librariesConfiguration
	}
}

dependencies {
	def librariesConfigurationName = Configurations.minecraftLibraries(minecraft_version)
	def librariesConfiguration = configurations.getByName(librariesConfigurationName)

	add librariesConfigurationName, 'net.fabricmc:fabric-loader:0.15.11'
	decompileClasspath 'org.vineflower:vineflower:1.10.1'

	for (def dependency : librariesConfiguration.getAllDependencies()) {
		implementation dependency
	}
}

tasks.withType(JavaCompile).configureEach {
	it.options.encoding = 'UTF-8'
	it.options.release = 8
}

java {
	sourceCompatibility = JavaVersion.VERSION_1_8
	targetCompatibility = JavaVersion.VERSION_1_8
}

task downloadMappings(type: Download) {
	def build = keratin.getNextFeatherBuild(minecraft_version) - 1 // we want the latest build, not the next one
	def url = "https://maven.ornithemc.net/releases/net/ornithemc/feather-gen${intermediary_gen}/${minecraft_version}+build.${build}/feather-gen${intermediary_gen}-${minecraft_version}+build.${build}-v2.jar"

	src UrlEscapers.urlFragmentEscaper().escape(url)
	dest featherJar

	doLast {
		copy {
			from({ zipTree(featherJar) }) {
				from 'mappings/mappings.tiny'
				rename 'mappings.tiny', "../${featherTiny.name}"
			}

			into featherTiny.parentFile
		}
	}
}

task makeSetupExceptions() {
	doLast {
		delete(setupExcs)

		if (excsOut.exists()) {
			Files.copy(excsOut.toPath(), setupExcs.toPath())
		} else {
			setupExcs.createNewFile()
		}
	}
}

task makeSetupSignatures() {
	doLast {
		delete(setupSigs)

		if (sigsOut.exists()) {
			Files.copy(sigsOut.toPath(), setupSigs.toPath())
		} else {
			setupSigs.createNewFile()
		}
	}
}

task makeSetupMappings(dependsOn: [downloadMappings, mapNestsToIntermediary], type: FillMappingsTask) {
	inputNamedMappings = featherTiny
	intermediaryMappings = intermediaryTiny
	namedMappings = mappingsTiny

	def nests = keratin.files.getMergedNests(minecraft_version)
	def intermediaryNests = keratin.files.getMainIntermediaryNests(minecraft_version)

	doFirst {
		delete(intermediaryTiny)
		delete(mappingsTiny)
		delete(mergedMappingsTiny)
	}
	doLast {
		if (nests != null) {
			Nester._nestMappings(
				intermediaryTiny,
				intermediaryTiny,
				nests
			)
			Nester._nestMappings(
				mappingsTiny,
				mappingsTiny,
				intermediaryNests
			)
		}

		def mergedMappings = new MemoryMappingTree();

		MappingReader.read(mappingsTiny.toPath(), mergedMappings);
		MappingReader.read(intermediaryTiny.toPath(), new MappingSourceNsSwitch(mergedMappings, 'intermediary'))

		def writer = MappingWriter.create(mergedMappingsTiny.toPath(), MappingFormat.TINY_2_FILE)
		def srcNsSwitch = new MappingSourceNsSwitch(writer, 'official')

		mergedMappings.accept(srcNsSwitch)
	}
}

task makeSetupJar(dependsOn: [mergeMinecraftJars, downloadNests, makeSetupExceptions, makeSetupSignatures]) {
	def jar = keratin.files.getMergedJar(minecraft_version)
	def nests = keratin.files.getMergedNests(minecraft_version)

	doLast {
		delete(setupJar)

		def tmp = new File(setupDir, ".tmp.jar")

		Exceptor._exceptionsPatchJar(
			jar,
			tmp,
			setupExcs
		)
		SignaturePatcher._signaturePatchJar(
			tmp,
			nests != null ? tmp : setupJar,
			setupSigs
		)
		if (nests != null) {
			Nester._nestJar(
				tmp,
				setupJar,
				nests
			)
		}

		delete(tmp)
	}
}

task patchSetupMappings(dependsOn: [makeSetupMappings, makeSetupJar], type: PatchAnonymousClassMappingsTask) {
	jar = setupJar
	mappings = mergedMappingsTiny
	targetNamespace = 'named'
}

task mapSetupJar(dependsOn: [makeSetupJar, patchSetupMappings]) {
	def libs = keratin.files.getLibraries(minecraft_version)

	doLast {
		delete(namedJar)

		Mapper._mapJar(
			setupJar,
			namedJar,
			mergedMappingsTiny,
			libs,
			'official',
			'named'
		)
	}
}

task makeSource(type: JavaExec, dependsOn: mapSetupJar) {
	mainClass.set("org.jetbrains.java.decompiler.main.decompiler.ConsoleDecompiler")
	classpath = configurations.decompileClasspath
	args namedJar.getAbsolutePath(), decompSrc.getAbsolutePath()

	doFirst {
		delete(decompSrc)
	}
}

task setUpSource(dependsOn: makeSource) {
	def srcJava = file('src/main/java/')

	doLast {
		delete(srcJava)

		for (def from : Files.walk(decompSrc.toPath())) {
			def name = decompSrc.toPath().relativize(from)
			def path = name.toString()

			if (path.endsWith('.java')) {
				def to = srcJava.toPath().resolve(path)
				def dir = to.getParent()

				Files.createDirectories(dir)
				Files.copy(from, to)
			}
		}

		delete(decompSrc)
	}
}

task makeBaseExceptions(dependsOn: mergeMinecraftJars) {
	def jar = keratin.files.getMergedJar(minecraft_version)

	doLast {
		delete(baseExcs)

		net.ornithemc.exceptor.Exceptor.extract(
			jar.toPath(),
			baseExcs.toPath()
		)
	}
}

task makeBaseSignatures(dependsOn: mergeMinecraftJars) {
	def jar = keratin.files.getMergedJar(minecraft_version)

	doLast {
		delete(baseSigs)

		GenerateAction.run(
			baseSigs.toPath(),
			List.of(jar.toPath()),
			EmptySignatureMode.IGNORE
		)
	}
}

task makeGeneratedJar(dependsOn: [build, patchSetupMappings]) {
	def jar = file("build/libs/${project.base.archivesName.get()}-${version}.jar")
	def libs = keratin.files.getLibraries(minecraft_version)

	doLast {
		delete(generatedJar)

		Mapper._mapJar(
			jar,
			generatedJar,
			mergedMappingsTiny,
			libs,
			'named',
			'official'
		)
	}
}

task makeGeneratedExceptions(dependsOn: [downloadNests, makeGeneratedJar]) {
	def nests = keratin.files.getMergedNests(minecraft_version)

	doLast {
		delete(generatedExcs)

		net.ornithemc.exceptor.Exceptor.extract(
			generatedJar.toPath(),
			generatedExcs.toPath()
		)
		if (nests != null) {
			MappingUtils.undoNestsToExceptions(
				generatedExcs.toPath(),
				generatedExcs.toPath(),
				nests.toPath()
			)
		}
	}
}

task makeGeneratedSignatures(dependsOn: [downloadNests, makeGeneratedJar]) {
	def nests = keratin.files.getMergedNests(minecraft_version)

	doLast {
		delete(generatedSigs)

		GenerateAction.run(
			generatedSigs.toPath(),
			List.of(generatedJar.toPath()),
			EmptySignatureMode.IGNORE
		)
		if (nests != null) {
			MappingUtils.undoNestsToSignatures(
				generatedSigs.toPath(),
				generatedSigs.toPath(),
				nests.toPath()
			)
		}
	}
}

task saveExceptions(dependsOn: [makeBaseExceptions, makeGeneratedExceptions]) {
	doLast {
		def base = ExceptorIo.read(baseExcs.toPath())
		def generated = ExceptorIo.read(generatedExcs.toPath())

		def cit = generated.classes.entrySet().iterator()

		while (cit.hasNext()) {
			def ce = cit.next()
			def clsName = ce.getKey()
			def generatedCls = ce.getValue()
			def baseCls = base.classes.get(clsName)

			if (baseCls != null) {
				def mit = generatedCls.methods.entrySet().iterator()

				while (mit.hasNext()) {
					def me = mit.next()
					def methodRef = me.getKey()
					def generatedMethod = me.getValue()
					def baseMethod = baseCls.methods.get(methodRef)

					if (baseMethod != null && Objects.equals(baseMethod.exceptions, generatedMethod.exceptions)) {
						mit.remove()
					}
				}

				if (generatedCls.methods.isEmpty()) {
					cit.remove()
				}
			}
		}

		if (!generated.classes.isEmpty()) {
			def sortedClasses = new TreeMap<>(generated.classes)
			generated.classes.clear()
			generated.classes.putAll(sortedClasses)
	
			for (def generatedClass : generated.classes.values()) {
				def sortedMethods = new TreeMap<>(generatedClass.methods)
				generatedClass.methods.clear()
				generatedClass.methods.putAll(sortedMethods)
			}
	
			ExceptorIo.write(excsOut.toPath(), generated)
		} else if (excsOut.exists()) {
			delete(excsOut)
		}
	}
}

class MemberReferenceComparator implements Comparator<MemberReference> {
	
	@Override
	public int compare(MemberReference r1, MemberReference r2) {
		def c = r1.name().compareTo(r2.name())
		return c != 0 ? c : r1.desc().getDescriptor().compareTo(r2.desc().getDescriptor())
	}
}

task saveSignatures(dependsOn: [makeBaseSignatures, makeGeneratedSignatures]) {
	doLast {
		def base = new SigsFile()
		def generated = new SigsFile()

		try (def br = Files.newBufferedReader(baseSigs.toPath())) {
			new SigsReader(br).accept(base)
		}
		try (def br = Files.newBufferedReader(generatedSigs.toPath())) {
			new SigsReader(br).accept(generated)
		}

		def cit = generated.classes.entrySet().iterator()
		
		while (cit.hasNext()) {
			def ce = cit.next()
			def clsName = ce.getKey()
			def generatedCls = ce.getValue()
			def baseCls = base.classes.get(clsName)

			if (baseCls != null) {
				def mit = generatedCls.members.entrySet().iterator()

				while (mit.hasNext()) {
					def me = mit.next()
					def methodRef = me.getKey()
					def generatedMember = me.getValue()
					def baseMember = baseCls.members.get(methodRef)

					if (Objects.equals(baseMember, generatedMember)) {
						mit.remove()
					}
				}

				if (generatedCls.members.isEmpty() && Objects.equals(baseCls.signatureInfo, generatedCls.signatureInfo)) {
					cit.remove()
				}
			}
		}

		if (!generated.classes.isEmpty()) {
			def sortedClasses = new TreeMap<>(generated.classes)
			generated.classes.clear()
			generated.classes.putAll(sortedClasses)
	
			for (def generatedClass : generated.classes.values()) {
				def sortedMembers = new TreeMap<>(new MemberReferenceComparator())
				sortedMembers.putAll(generatedClass.members)
				generatedClass.members.clear()
				generatedClass.members.putAll(sortedMembers)
			}
	
			try (def bw = Files.newBufferedWriter(sigsOut.toPath())) {
				generated.accept(new SigsFileWriter(bw))
			}
		} else if (sigsOut.exists()) {
			delete(sigsOut)
		}
	}
}

task save(dependsOn: [saveSignatures, saveExceptions]) {
}

def ENV = System.getenv()
def maven_url = ENV.MAVEN_URL
def maven_group = 'net.ornithemc'
def maven_group_for_url = 'net.ornithemc'.replace('.', '/')
def raven_artifact_id = 'raven'
def sparrow_artifact_id = 'sparrow'
def ravenVersions = new HashMap<String, Integer>()
def sparrowVersions = new HashMap<String, Integer>()

void fetchPublishedVersions(def maven_url, def maven_group_for_url, def artifact_id, def publishedVersions) {
	try {
		def xml = new URL("${maven_url}/${maven_group_for_url}/${artifact_id}/maven-metadata.xml").text
		def metadata = new XmlSlurper().parseText(xml)
		metadata.versioning.versions.version.each {
			String[] version = it.text().split(Pattern.quote('+build.'))
			String mcVersion = version[0]
			int build = Integer.parseInt(version[1])
			publishedVersions.compute(mcVersion, (key, value) -> value == null || build > value ? build : value)
		}
	} catch (FileNotFoundException ignored) {
		// only happens if no publications exist yet
	}
}

void makePublications(def dir, def ext, def versions, def maven_url, def maven_group, def maven_group_for_url, def artifact_id, def dir_in_jar) {
	def tmp = project.file('build/tmp/')

	dir.eachFile { file ->
		if (!file.name.endsWith(ext)) {
			return
		}

		def mcVersion = file.name.substring(0, file.name.length() - ext.length())
		def prevBuild = versions.getOrDefault(mcVersion, 0)

		if (prevBuild > 0) {
			def prevVersionBuild = "${mcVersion}+build.${prevBuild}"
			def prevJar = new File(tmp, "build-${prevBuild}.jar")
			def prevFile = new File(tmp, "build-${prevBuild}${ext}")

			download {
				src new URL("${maven_url}/${maven_group_for_url}/${artifact_id}/${prevVersionBuild}/${artifact_id}-${prevVersionBuild}.jar")
				dest prevJar
				overwrite true
			}
			copy {
				from({ zipTree(prevJar) }) {
					from "${dir_in_jar}/mappings${ext}"
					rename "mappings${ext}", "../${prevFile.name}"
				}

				into prevFile.parentFile
			}

			if (FileUtils.contentEquals(file, prevFile)) {
				return
			}
		}

		def nextBuild = prevBuild + 1
		def nextVersionBuild = "${mcVersion}+build.${nextBuild}"

		def makeJar = task("${mcVersion}_${dir_in_jar}_makeJar", type: Jar) {
			archiveFileName = "${artifact_id}-${nextVersionBuild}${ext}"
			from(project.file(file)) {
				into dir_in_jar
				rename file.name, "mappings${ext}"
			}
			destinationDirectory = project.file("build/jars")
		}
	
		build.dependsOn makeJar
	
		publishing {
			publications {
				create("${mcVersion.replace(" ", "")}_${dir_in_jar}_mavenJava", MavenPublication) {
					groupId maven_group
					artifactId artifact_id
					version nextVersionBuild
					artifact(makeJar)
				}
			}
		}
	}
}

if (maven_url) {
	fetchPublishedVersions(maven_url, maven_group_for_url, raven_artifact_id, ravenVersions)
	fetchPublishedVersions(maven_url, maven_group_for_url, sparrow_artifact_id, sparrowVersions)

	makePublications(excsDir, '.excs', ravenVersions, maven_url, maven_group, maven_group_for_url, raven_artifact_id, 'exceptions')
	makePublications(sigsDir, '.sigs', sparrowVersions, maven_url, maven_group, maven_group_for_url, sparrow_artifact_id, 'signatures')

	publishing {
		repositories {
			if (maven_url) {
				maven {
					url maven_url
					credentials {
						username ENV.MAVEN_USERNAME
						password ENV.MAVEN_PASSWORD
					}
					authentication {
						basic(BasicAuthentication)
					}
				}
			}
		}
	}
}
